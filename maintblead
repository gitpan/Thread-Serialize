#-------------------------------------------------------------------------------
# This file was auto-generated by Devel::MaintBlead 0.05 on
# Mon Jun 11 10:18:12 2012.

# can also be called from Devel::MaintBlead, we need the main:: package
package main;

# mark that we've run this (for testing mostly)
$Devel::MaintBlead::SIZE=  4491;

# huh?
if ( !$LIB_TREE or !$REQUIRED ) {
    print STDERR <<'HUH';

Please make sure the global variables $LIB_TREE and $REQUIRED are set before
using the Devel::MaintBlead module in your Makefile.PL.

HUH
    exit 1;
}

# private initializations
my @lib_tree=   split "/", $LIB_TREE;
$lib_tree[$_]= "$lib_tree[ $_ - 1 ]/$lib_tree[$_]" foreach 1 .. $#lib_tree;
my @postfix=    qw( blead maint );
my %maint=      map { $postfix[$_] => $_ } 0 .. $#postfix;
my $auto_maint= ( $] < $REQUIRED ) || 0;

#-------------------------------------------------------------------------------
# set up file moving logic
use File::Copy ();
sub mv {
    if ( -e $_[1] ) {
        print STDERR <<"HUH";
Cowardly refusing to overwrite

 $_[1]

from

 $_[0]

This should not happen.  Please advise the author of Devel::MaintBlead on
how you managed to do this.  Thank you!
HUH
        exit 1;
    }

    return File::Copy::mv(@_);
} #mv
#-------------------------------------------------------------------------------

# first time running Makefile.PL
if ( !-e 'pm_to_blib' ) {

    # set default setting
    $MAINT= !glob( "lib_$postfix[1]/$LIB_TREE/*" ) || 0;
    open( OUT, ">default" );
    print OUT $postfix[$MAINT];
    close OUT;
}

# do we have an override?
if (@ARGV) {
    my $type= shift @ARGV;
    $MAINT= $maint{$type};

    # huh?
    if ( !defined $MAINT ) {
        print STDERR "Don't understand '$type' to force version to test / install";
        exit 1;
    }

    print STDERR "Forcing to use the '$type' version of the code\n";
    open( OUT, ">default" );
    print OUT $postfix[$MAINT];
    close OUT;
}

# get default setting if necessary
else {
    open( IN, 'default' );
    $MAINT= $maint{ <IN> };
    close IN;
}

# sorry, we can't help you
if ( $auto_maint and !$MAINT ) {

    # can't do blead, autoselect active, so go to main
    if ( $ENV{AUTO_SELECT_MAINT_OR_BLEAD} ) {
        $MAINT=1;
    }

    # alas, can't do blead
    else {
        $REQUIRED= sprintf '%1.6f', $REQUIRED;
        print STDERR <<"SORRY";

This distribution requires at least Perl $REQUIRED to be installed.  Since this
is an older distribution, with a history spanning almost a decade, it is also
available inside this distribution as a previous incarnation, which is actively
maintained as well.

You can install that version of this distribution by running this $0
with the additional "maint" parameter, like so:

 $^X $0 maint

Or you can provide an automatic selection behavior, which would automatically
select and install the right version of this distribution for the version of
Perl provided, by setting the AUTO_SELECT_MAINT_OR_BLEAD environment variable
to a true value.  On Unix-like systems like so:

 AUTO_SELECT_MAINT_OR_BLEAD=1 $^X $0

Thank you for your attention.

SORRY

        my $line= (caller)[2];
        eval <<"BYEBYE" or print STDERR $@;
#line $line $0
require $REQUIRED;
BYEBYE
        exit 1;
    }
}

# create shortcuts
my $this= $postfix[$MAINT];
my $that= $postfix[ !$MAINT ];

# make sure empty directories exist, 'make dist' doesn't include them
foreach my $postfix (@postfix) {
    mkdir "lib_$postfix";
    mkdir "lib_$postfix/$_" foreach @lib_tree;
    mkdir "t_$postfix";
}

# need to move files into place
if ( my @files= glob( "lib_$this/$LIB_TREE/*" ) ) {
    print STDERR "Moving $this files into position\n";

    # move current files away
    mv "MANIFEST", "MANIFEST_$that";
    mv "lib/$LIB_TREE/$_", "lib_$that/$LIB_TREE/${_}_$that"
      foreach
        map { m#/([^/\.]+\.pm)$# }
        glob( "lib/$LIB_TREE/*" );
    mv "t/$_", "t_$that/${_}_$that"
      foreach
        map { m#/([^/\.]+\.t)$# }
        glob( "t/*" );

    # put files into place
    mv "MANIFEST_$this", "MANIFEST";
    mv "lib_$this/$LIB_TREE/${_}_$this", "lib/$LIB_TREE/$_"
      foreach
        map { m#/([^/\.]+\.pm)_$this$# }
        @files;
    mv "t_$this/${_}_$this", "t/$_"
      foreach
        map { m#/([^/]+\.t)_$this$# }
        glob( "t_$this/*" );

    # make sure we will copy to blib
    unlink glob( "blib/lib/$LIB_TREE/*" );
}

# right files already there
else {
    print STDERR "Files for $this already in position\n";
}
